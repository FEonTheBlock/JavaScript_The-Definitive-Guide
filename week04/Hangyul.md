# 12장 이터레이터와 제너레이터


제너레이터의 일차적 설계목적: 이터레이터를 쉽게 생성하는 것


# 12.1 이터레이터의 동작 방법

- 순회를 이해하려면 알아야 할 세가지
    1. 이터러블 객체
        - 배열, 세트, 맵 등 순회할 수 있는 타입의 객체
        - 이터레이터 객체를 반환하는 이터레이터 메서드를 가진다.
    2. 이터레이터 객체
        - 순회를 수행한다
        - 순회결과 객체를 반환하는 `next()` 메서드를 가진다.
    3. 순회 결과 객체
        - `value`와 `done` 프로퍼티를 갖는다.
    - 순회 process
        - 이터레이터 메서드 호출 → 이터레이터 객체 GET!
        - 이터레이터 객체의 `next()` 메서드 반복호출 → 반환하는 순회결과 객체의 `done` 프로퍼티가 true일 때까지
    - 이터러블 데이터 타입의 이터레이터 객체는 그 자체가 이터러블로, 자기 자신을 반환하는 이터레이터 메서드를 갖는다.


# 12.2 이터러블 객체 만들기

- 클래스를 이터러블로 만드려면
    - 이름이 `Symbol.iterator`인 메서드가 있어야
    - `Symbol.iterator` 메서드는 `next()` 메서드가 있는 이터레이터 객체 반환
    - `next()` 메서드는 순회결과 객체를 반환해야
    - 순회결과 객체는 `value` 프로퍼티와 `done` 프로퍼티 중 하나를 가져야
- 이터러블 값 반환 함수를 정의하면 매우 유용
- 이터러블 객체와 이터레이터의 특징: **lazy!**
    - 값이 필요할 때까지 계산을 늦춘다.
- 이터레이터 종료: `return()`
    - 끝까지 실행되지 않더라도 마지막에 할 작업(파일 닫기, 메모리 반환 등)을 정의
    - 반드시 순회결과 객체를 반환


# 12.3 제너레이터

- 순회할 값이 데이터 구조의 요소가 아니라 계산결과일 때 유용
    - 계산을 통해 전달할 값을 실제로 `생성`할 때!
- 제너레이터를 만드려면 먼저 제너레이터 함수를 정의해야 함
    - `function` 대신 `function*` 키워드 사용하여 함수 정의
    - 제너레이터 함수를 호출하면 함수몸체 실행이 아니라 제너레이터 객체 반환
    - 제너레이터 객체 (==  이터레이터):`next()`를 호출하면 제너레이터 함수 몸체의 처음 or 현재 위치에서 코드를 실행하다가 `yield` 문에서 정지하고, `yield`문 값을 반환
    - 표현식 형태로도 정의 가능
    - 클래스나 객체 리터럴에서는 메서드 앞에 `*`를 붙여 제너레이터로 정의
    - 화살표 함수 문법으로 정의 불가
- 무한한 제너레이터를 과도한 메모리 소진 없이 필요한만큼만 호출 가능
- `yield*` 키워드로 이터러블 객체를 순회하며 각각의 값을 전달
    - 재귀 제너레이터를 만들 수 있고, 재귀적으로 정의된 트리구조를 비재귀적으로 순회 가능


# 12.4 고급 제너레이터 기능

- 제너레이터 특징
    - 이터레이터의 손쉬운 생성
    - 계산을 잠시 멈추고 중간값을 전달한 후 계산 재개
- 값을 반환하는 제너레이터에서 `next()`를 마지막으로 호출했을 때 반환하는 객체에서!
    - 제너레이터 함수의 반환값을 담고 있는 `value` 프로퍼티와 `true` 값을 가진 `done` 프로퍼티가 존재
- `yield`는 표현식이므로 값을 가질 수 있다 == 값으로 평가될 수 있다?
    - `yield` 다음의 표현식이 평가된 값이 `next()`의 반환 값
    - 다음 `next()` 호출 시 인자로 전달하는 값이 `yield`가 평가되는 값
    - 제너레이터는 `yield`로 호출자에게 값을 반환하며 호출자는 `next()`를 통해 제너레이터에 값 전달
- `return`과 `throw`로도 제너레이터의 실행 흐름 제어 가능
    - 제너레이터의 다음 문이 `return`이나 `throw` 였던 것처럼 값을 반환하거나 예외를 일으킬 수 있음
    - 제너레이터에서는 이터레이터처럼 커스텀 `return()` 메서드를 만들 수는 없지만 `try/finally`로 제너레이터가 종료될 때 정리 작업 수행 가능
        - 제너레이터를 강제 종료하면 ~ 이부분 이해 못함
- 제너레이터를 사용하여 싱글 스레드 JS를 스레드 협업시스템으로 만들 수 있다.
- 제너레이터로 비동기 부분을 감싸면 프로그램을 동기적으로 보이게 할 수 있다.
    - `async` `await` 키워드의 등장으로 이렇게 활용할 이유는 이제 없어졌다.