## 12.1 이터레이터의 동작 방법

for/of 루프와 분해 연산자는 이터러블 객체와 잘 어울린다

순회할 때 정확히 어떤 일이 일어나는지 이해해보자

자바스크립트의 순회를 이해하려면 세가지를 이해해야한다

1. 이터러블 객체
    
    이터러블 객체는 배열, Set, Map 같은 순회할 수 있는 타입의 객체
    
2. 이터레이터 객체
    
    순회를 수행하는 이터레이터 객체 자체
    
3. 순회 결과 객체 (iteration result)

이터레이터 객체를 반환하는 이터레이터 메서드를 가진 객체는 모두 이터러블 객체다

순회 결과 객체를 반환하는 next() 메서드가 있는 객체는 모두 이터레이터 객체다

순회 결과 객체는 value와 done 프로퍼티가 있는 객체

이터러블 객체를 순회할 때는 먼저 이터레이터 메서드를 호출해 이터레이터 객체를 얻는다

그리고 이터레이터 객체의 next() 메서드를 반복적으로 호출하며 반환 값의 done 프로퍼티가 true일 때 까지 반복한다

for/of 루프를 다음과 같이 복잡하게 작성할 수 도 있다

```jsx
let iterable = [99];
let iterlator = iterable[Symbol.iterator]();
for(let result = iterator.next(); !result.done; result = iterator.next()){
	console.log(result.value) //result.value == 99
}
```

내장된 이터러블 데이터 타입의 이터레이터 객체는 그 자체가 이터러블 이다

⇒ 자기 자신을 반환하는 Symbol.iterator 메서드를 갖는다는 뜻

부분적으로 사용된 이터레이터를 순회할 때 이런 특징이 유용하다

```jsx
let list = [1,2,3,4,5];
let iter = list[Symbol.iterator]();
let head = iter.next().value; // head == 1
let tail = [... iter]; // tail == [2,3,4,5]
```

## 12.2 이터러블 객체 만들기

이터러블 객체는 아주 편리하므로 순회할 수 있는 데이터타입이라면 이터러블로 만드는 것을 고려하자

클래스를 이터러블로 만들기 위해서는 이름이 Symbol.iterator

이 메서드는 반드시 next() 메서드가 있는 이터레이터 객체를 반환해야한다.

next() 메서드는 반드시 순회 결과 객체를 반환해야하며 순회 결과 객체에는 value 프로퍼티와 불 done 프로퍼티 중 하나는 반드시 존재해야 한다.

이터러블 객체와 이터레이터의 핵심 특징 중 하나는 이들이 본질적으로 느긋(lazy) 하다는 것이다.

다음 값을 얻기 위해 계산이 필요하다면 그 값이 실제로 필요할 때까지 계산을 늦출 수 있습니다.

예를 들어 아주 긴 문자열이 있고 이 문자열을 공백으로 구분된 단어로 토근화 할때

단순히 split()메서드를 사용할 수 도 있지만

첫번째 단어만 사용하는 경우에도 문자열 전체를 처리할 때까지 기다려야한다.

또한 반환된 배열과 배열 내 문자열에 메모리를 아주 많이 할당해야한다.

### 12.2.1 이터레이터 ‘종료’:  return 메서드

서버사이드에서 파일이름을 인자로 받고, 파일을 열어서 콘텐츠를 읽은 다음 그 콘텐츠의 단어를 순회하는 걸 만들때

운영체제에서 파일을 여는 프로그램은 읽기를 마쳤을때 파일을 닫아야 하므로, 이 가상의 이터레이터 역시 next() 메서드가 마지막 단어를 반환할때 파일을 닫아야 한다

하지만 이터레이터가 항상 끝까지 실행되지는 않는다

for/of 루프는 break, return문을 만나거나 예외가 일어났을 때 종료된다

마찬가지로 이터레이터를 분해할당과 함께 사용하면 next()메서드는 지정된 변수 각각의 값을 얻을 수 있을만큼 호출된다.

가상의 파일 이터레이터가 끝까지 실행되는 일이 절대 없더라도 파일을 닫을 수 있는 방법이 있어야한다

이 때문에 이터레이터 객체에서 next() 메서드 외에 return() 메서드가 사용되기도 한다.

return() 메서드는 반드시 순회 결과 객체를 반환해야 한다

객체의 프로퍼티는 무시되지만 객체가 아닌 값을 반환하면 에러가 일어난다

for/of 루프와 분해 연산자는 정말 유용한 기능이므로 API를 만들 때 가능하면 이들을 사용하는 것이 좋다

하지만 이터러블 객체, 이터레이터 객체, 순회결과 객체를 함께 사용하면 상당히 복잡하다

다행히 제너레이터를 사용하면 커스텀 이터레이터를 정말 쉽게 만들 수 있다.

## 12.3 제너레이터

제너레이터는 ES6의 강력한 새 문법을 사용한 일종의 이터레이터이다.

제너레이터는 순회할 값이 데이터 구조의 요소가 아니라 계산 결과일때 특히 유용하다.

제너레이터를 만들기 위해서는 반드시 먼저 제너레이터 함수를 정의해야한다.

제너레이터 함수는 문법적으로는 자바스크립트 함수와 비슷하지만 function 대신 function* 키워드를 사용한다

제너레이터 함수를 호출하면 실제로 함수 바디를 실행하지는 않고 제너레이터 객체를 반환한다

이 제너레이터 객체는 이터레이터 이다

제너레이터 객체의 next() 메서드를 호출하면 제너레이터 함수의 바디가 처음 또는 현재 위치에서 실행되며 yield문을 만나면 멈춘다.

yield는 es6에서 처음 등장했으며 return 문과 비슷하다

이터레이터에서 next()를 호출하면 yield문의 값을 반환한다.

제너레이터는 function* 문, 표현식 둘다 만들 수 있다.

클래스와 객체리터럴에서는 메서드를 정의할때 function 키워드를 완전히 생략한 단축 프로퍼티 표기법을 쓸 수 있다.

화살표 함수 문법으로는 제너레이터 함수를 정의할 수 없다

yield* 키워드는 yield와 비슷하지만 값 하나를 전달하는 것이 아니라 이터러블 객체를 순회하면서 각각의 값을 전달한다

yield와 yield*는 제너레이터 함수 안에서만 사용할 수 있다.

## 12.4 고급 제너레이터 기능

제너레이터 함수는 가장 흔하게는 이터레이터를 만드는데 사용되지만 제너레이터는 기본적으로 계산을 잠시 멈추고 중간 값을 전달한 다음 계산을 재개할 수 있다는 특징도 있다.

yield는 표현식이라서 값을 가질 수 있다

next()메서드를 호출하면 제너레이터 함수는 yield표현식을 만날 때까지 실행된다.

yield 키워드 다음에 있는 표현식을 평가한 값이 next()의 반환값이다.

제너레이터 함수가 전달(yield)하거나 반환(return)하는 값을 받을 수 있다.

그리고 제너레이터의 next()메서드를 호출할 때 이 값을 넘겨 실행 중인 제너레이터에 전달 할 수 있다.

next()를 통해 제너레이터에 값을 전달하는 것 이외에도 return() 과 throw() 메서드를 호출해서 제너레이터의 실행 흐름을 제어할 수 있다.

제너레이터를 강제 종료하면 내장된 return()메서드는 제너레이터가 더 이상 사용되지 않을때 정리 코드가 실행되도록 한다.

throw() 메서드를 쓰면 임의의 신호를 예외의 형태로 제너레이터에 보낼 수 있다.

throw() 메서드를 호출하면 항상 제너레이터에서 예외가 발생한다.

제너레이터는 아주 강력하고 일반화된 제어문이다

제너레이터를 사용해서 싱글 스레드를 사용하는 자바스크립트 코드를 모아서 일종의 스레드 협업 시스템을 만들 수 있다.
