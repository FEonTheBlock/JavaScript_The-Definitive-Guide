## 13.3 async와 await

- ES2017
- 프로미스 사용을 극적으로 단순화하며 프로미스 기반의 비동기 코드를 동기적 코드처럼 작성할 수 있게 한다.
- 비동기 코드는 일반적인 동기적 코드와 같은 방법으로 값을 반환하거나 예외를 일으킬 수 없다
- 이행된 프로미스의 값은 동기적 함수의 반환 값과 같다
- 거부된 프로미스의 값은 동기적 함수에서 일으킨 에러와 같다
- 효율적인 프로미스 기반 코드에서 프로미스를 숨겨, (비효율적이지만) 읽기 쉽고 이해하기 쉬운 동기적 코드와 비슷하게 만든다

### 13.3.1 await 표현식

- await 키워드는 프로미스를 받아 반환 값이나 예외로 바꾼다
- 프로미스 객체 p가 있을 때 표현식 await p는 p가 완료될때까지 대기한다
- p가 이행되면 await p의 값은 p가 이행된 값입니다
- p가 거부되면 await p 표현식은 p와 같은 값을 예외로 일으킨다
- await은 보통 프로미스를 할ㄹ당한 변수와 함께 사용하기보다는 프로미스를 반환하는 함수와 함께 사용한다.
- await 키워드는 프로그램 흐름을 차단하지 않으며 지정된 프로미스가 완료되기 전에는 아무일도 하지 않는다
- 코드는 여전히 비동기적이지만 await이 그 사실이 드러나지 않게 하는 것 뿐이다
- await을 사용하는 코드는 항상 비동기적이다

### 13.3.2 async 함수

- 함수를 async로 선언하면 설령 함수 바디에 프로미스 관련 코드가 전혀 없더라도 반환 값은 프로미스이다
- async 함수가 정상적으로 완료되면 함수의 실제 반환 값인 프로미스 객체는 함수 바디가 반환하는 (것처럼 보이는) 값으로 해석된다.
- async가 예외를 일으키면 반환된 프로미스 객체 역시 그 예외와 함께 거부된다.

### 13.3.3 여러개의 프로미스 대기

```jsx
let value1 = await getJSON(url1);
let value2 = await getJSON(url2);
```

두번째 URL이 첫 번째 URL의 값과 관계가 없다면 두 값을 동시에 가져올 수 있어야 한다

async 함수는 프로미스에 기반하므로 어려운 일은 아니다

프로미스를 직접 사용할 때와 마찬가지로 Promise.all()을 사용하면 된다

```jsx
let [value1, value2] = await Promise.all([getJSON(url1),getJSON(url2)]);
```

### 13.3.4 세부사항

```jsx
async function f(x) {}
```

```jsx
function f(x){
	return new Promise(function(resolve, reject){
		try{
			resolve((function(x) {})(x));
		}
		catch(e){
			reject(e);
		}	
	});
}
```

async 함수를 원래 함수를 감싸는, 프로미스를 반환하는 함수라고 생각하자

await 키워드를 함수 바디를 동기적 덩어리로 구분하는 일종의 표식이라고 생각하자

es2017 인터프리터는 함수 바디를 일련의 하위 함수 여러 개로 분해할 수 있으며 각 하위 함수는 자신의 앞에 있는 await로 표시된 프로미스의 then() 메서드에 전달 된다

## 13.4 비동기 순회

- 프로미스는 setInterval()이나 웹 브라우저의 클릭 이벤트처럼 여러번 일어 날 수 있는 비동기 작업에는 적합하지 않다
- 프로미스 하나로는 비동기 이벤트 시퀀스에 대응할 수 없으므로 async 함수와 await문으로도 비동기 이벤트 시퀀스에 대응할 수 없다
- 하지만 es2018에서 해결책이 나왔다
- 비동기 이터레이터는 이터레이터와 비슷하지만 프로미스 기반으로 만들어졌고 for/of 루프의 새 형태인 for/await와 함께 사용하도록 설계되었다.
- for/await 루프는 루프에 await 호출을 결합하고 코드를 좀 더 간결하게 만들었을 뿐 똑같이 동작한다

### 13.4.2 비동기 이터레이터

- 비동기 이터러블 객체는 심벌이름 Symbol.asyncIterator를 가진 메서드가 있다
- for/await은 일반적인 이터러블 객체와도 호환되지만 비동기 이터러블 객체를 선호하며  Symbol.Iterator 보다 Symbol.asyncIterator 를 먼저 시도한다
- 비동기 이터레이터의 next() 메서드는 직접적으로 순회 결과 객체를 반환하는 것이 아니라 순회 결과 객체로 해석되는 프로미스를 반환한다.

## 14.1 프로퍼티 속성

- 자바스크립트 객체의 프로퍼티에는 그 프로퍼티가 어떻게 동작하는지 나타내는 세가지 속성이 있다
    - 쓰기가능
    - 열거가능
    - 변경가능

## 14.2 객체 확장성

- 확장 가능 속성을 객체에 새로운 프로퍼티를 추가할 수 있는지 결정한다
- 일반적인 자바스크립트 객체는 기본적으로 확장 가능이다
- 객체가 확장 가능인지 확인하려면 Object.isExtensible()을 사용
- 객체를 확장 불가로 만드려면 Object.preventExtensions()에 전달
- 이렇게 하면 객체의 새로운 프로퍼티를 추가하려 할때 스트릭트 모드에서는 TypeError 가 일어나고 일반 모드에서는 에러없이 조용히 실패한다
- 또한 확장 불가인 객체의 프로토타입을 변경하려는 시도는 항상 TypeError를 일으킨다
- 객체를 확장 불가로 만든 후 에는 다시 확장 가능으로 되돌릴 방법이 없다
- Object.preventExtensions()는 객체 자체의 확장성만 제어한다.
- 확장 불가인 객체의 프로토타입에 새로운 프로퍼티를 추가하면 새로운 프로퍼티는 그대로 상속된다.
- 확장 가능 속성의 목적은 객체를 현재 상태로 유지하고 바깥에서 손댈 수 없도록 잠그는 것
- Object.seal()은 Object.preventExtensions()와 비슷하지만 객체를 확장 불가로 만드는 동시에 자체 프로퍼티를 모두 변경 불가로만든다.
- Object.freeze()는 객체를 더 단단히 잠군다. 객체는 확장 불가, 프로퍼티는 변경 불가로 바뀌고 객체 자체 데이터 프로퍼니틑 모두 읽기 전용으로 바뀐다.
