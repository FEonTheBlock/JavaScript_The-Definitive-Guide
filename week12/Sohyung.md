# 노드와 서버 사이드 자바스크립트
> 배운 내용?

- 노드의 분명한 특징: 태생부터 비동기적인 API를 바탕으로 한 싱글 스레드의 이벤트 기반 병렬 환경
- 노드: 운영 체제와 연결된 자바스크립트로 자바스크립트 프로그램에서 파일을 읽고 쓰고, 자식 프로세스를 실행하고 네트워크를 통해 통신할 수 있게 한다.
- 노드의 용도:
  - 배시나 기타 유닉스 셸의 복잡한 문법에서 해방
  - 신뢰할 수 없는 코드를 다루는 웹 브라우저에 적용되는 보안 제한에서 벗어나 신뢰할 수 있는 프로그램을 실행하는 범용 프로그래밍 언어
  - 효율적이고 병렬화된 웹 서버 환경

- 관련 링크
  - [노드 공식문서: api](https://nodejs.org/api/)
  - [노드 공식 문서: 가이드](https://nodejs.org/en/docs/guides/)


## 16.1 노드 프로그래밍 기본
> 노드 프로그램이 어떻게 운영 체제와 상호작용하는가

- 콘솔 출력 
  - console.log() 로 사용자에게 메시지를 표준하거나 표준 출력 스트림(stdout)에 출력할 수 있다.
  - console.error() 로 표준 에러(stderr) 스트림에 기록한다.

- 명령행 인자와 환경 변수
  - **`progress.argv`** (문자열 배열)
  - 첫 번째 요소: 노드 실행 파일의 절대 경로
  - 두 번째 요소: 노드가 실행하고 있는 자바스크립트 코드 파일의 절대 경로
  - 남은 요소: 노드 호출시 명령행에 쓴 인자를 공백으로 구분한 결과

- 프로그램 수명
  - node 명령어를 통해 실행할 자바스크립트 파일을 명령행 인자에서 참고한 정보를 통해 실행한다. 여기서 다른 모듈을 가져오고 자체 클래스나 함수를 정의한다. 기본적으로 파일의 코드를 순차적으로 실행한다.
  - 노드 프로그램은 **초기 파일 실행 후 콜백을 모두 호출한 뒤 남은 이벤트가 없을 때까지 종료되지 않는데**, 네트워크 연결을 주시하는 노드 기반 서버프로그램은 항상 이벤트를 기다리고 있으므로 이론적으로는 영원히 실행된다.
  - 강제 종료: `process.exit()`
  - 터미널에서 ctrl + c 
    - process.on("SIGNT", ()=>{}) 로 시그널 핸들러 함수를 틍록해 종료 단축키 무시할 수 있음
  - 예외가 일어났는데 catch 절이 없는 경우 에러를 출력하고 자동 종료
    - 전역 핸들러 함수를 등록해 자동 종료를 맏을 수 있음 
    - `process.on("unhandledRejection", (reason, promise) => { //... })`

- 노드 모듈
  - CommonJS 모듈
    - require() 함수로 모듈에 값을 가져오고 exports 객체 혹은 module.exports 프로퍼티로 값을 내보낸다.
  - 노드 13 부터는 ES6 모듈 표준도 추가로 지원
    - 노드가 모듈을 불러오기 전 require(), module.exports를 사용하는지 import, export를 사용하는지 알아내 둘 중 하나를 활성화 한다.
    - 모듈 종류를 노드에 알리는 방법
      - 확장자로 구분 (가장 단순)
        - .mjs -> ES6 모듈로 간주
        - .cjs -> CommonJS 모듈로 간주
      - 가장 가까운 package.json의 JSON 객체에서 최상위 type 프로퍼티를 체크
        - type: module -> ES6
        - type: commonjs -> CommonJS
      - package.json 파일이 없고 확장자로 구분이 안 될 때
        - 기본적으로 CommonJS 모듈로 간주
    - ES6와 CommonJS 간의 호환
      - ES6 모듈이 import를 사용해 커먼제이에스 모듈을 불러올 수 있음
      - 반대는 불가

- 노드 패키지 매니저 (npm)
  - 노드를 설치하면 일반적으로 함께 설치됨
  - 루트 디렉토리의 package.json 파일에 의존 패키지와 프로그램에 대한 정보를 저장한다.


## 16.2 노드는 기본적으로 비동기적입니다
노드는 서버 생성을 단순화하기 위해 자바스크립트의 싱글스레드 프로그래밍 모델을 받아들였다.

노드의 진정한 병렬화
- 노드 프로그램은 운영체제의 프로세스를 여러 개 실행할 수 있으며, 노드 10부터 Worker 객체를 지원한다. 
- 서버처럼 입출력 집약적인 프로그램에서는 널리 쓰이지 않지만, 프로세스 사이의 통신, 워커 사이의 통신은 메시지를 통해 이뤄지며 메모리가 쉽게 공유되지 않아 멀티스레드 프로그래밍의 복잡함 보다는 많이 간단하다.

노드는 기본적으로 비동기, 비차단 방식 API를 채택 : 싱글스레드 모델을 우지하면서도 높은 수준의 동시성을 구현한다.
네트워크에서 데이터를 읽고 쓰는 함수 뿐만 아니라 로컬 파일시스템을 읽고 쓰는 것에도 비차당, 비동기 함수를 지원한다. 하드디스크의 파일에 대한 작업을 할 깨 필요한 탐색시간, 또 네트워크 지연 시간이 생길 가능성이 있기 때문이다.

(중략...)

## 16.3 버퍼
노드 데이터 타입 중 하나로 (Buffer) 클래스가 있다.
> 문자 시퀀스가 아닌 **바이트 시퀀스**이다. 
> Unit8Array 의 서브클래스다.

- 지원되는 인코딩
  - utf8
  - utf16le
  - latin1
  - ascii
  - hex
  - base34

## 16.4 이벤트와 아밴트 미디어

## 16.5 스트림

스트리밍 알고리즘의 요점은 데이터를 항상 작은 덩어리로 처리하며 절대 데이터 전체를한번에 메모리에 담지 않는다는것

노드의 네트워크 API는 스트리밍 기반이고 노드의 파일시스템 모듈 역시 파일을 읽고 쓰는 스트리밍 API를 갖추고 있다.

- 리더블 스트림: 데이터 소스 (지정된 데이터를 반환하는 fs.createReadStream(), process.stdin)
- 라이터블 스트림: 데이터가 향하는 대상. (fs.createWriteStream() 의 반환값은 데이터를 덩어리 단위로 쓸 수 있게 하고 그 전체를 지정된 팡리에 출력)
- 듀플렉스 스트림: 리더블 스트림과 라이터블 스트림을 객체 하나에 조합 (net.connect() 이 반환하는 소켓 객체...) 
- 트랜스폼 스트림: 듀플렉스처럼 읽고 쓸 수 있지만 중요한 차이점은 스트림에 출력된 데이터(보통 다른 형태로 가공된)을 같은 스트림에서 읽을 수 있다는 것

### 16.5.1 파이프
리더블 스트림의 파이프로 연결만 하면 데이터를 읽고 쓰는 코드 작성할 필요 없이 노드가 알아서 해준다.
pipe() 메서드에 라이터블 스트림을 전달하기만 하면 된다.

### 16.5.3 스트림 기록과 배압 처리

write()메서드를 호출하면 전달받은 데이터를 항상 수락하고 버퍼에 담는다. 내부 버퍼가 아직 꽉 차지 않았으면 true, 거의 꽉 찼거나 그 이상이면 false를 반환한다. 
이 false 반환값은 스트림에서 처리할 수 있는 속도보다 더 빠르게 데이터를 보내고 있다는 메시지이며 일종의 배압이다. 이때 좋은 처리 방법은 drain(버퍼에 다시 공간이 생겼다는 신호) 이벤트를 방사할 때까지 write() 호출을 멈추는 것이다.

### 16.5.4 이벤트로 스트림 읽기

## 16.6 프로세스, CPU, 운영 체제 세부 사항

전역 객체 Process: 현재 실행 중인 노드 프로세스의 상태에 관련된 유용한 프로퍼티와 함수
(process.argv, process.cwd() ...)
os 모듈: 컴퓨터와 운영 체제에 관한 세부 사항 제공 (CPU 아키텍처, 컴퓨터 호스트 이름, 가용 RAM 양...)
