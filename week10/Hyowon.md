## 15.7 SVG

- SVG는 이미지 형식이다
- 해상도와 관계 없음
- 확대/축소가 자유롭다
- xml 마크업 언어를 사용해 작성
- 웹 브라우저에서 svg를 사용하는 방법
    - 이미지 태그
    - svg 태그
    - dom api를 사용해 동저으로 svg 요소 생성
    

### 15.7.1 HTML 속 SVG

- html 안에 svg를 직접 쓰면 css를 사용해 폰트, 색깔, 행 너비 등을 지정할 수 있다.
- 일반적인 css 스타일 프로퍼티와 다른 프로퍼티를 사용한다
    - fill, stroke-width, text-anchor
- font 단축 프로퍼티가 동작하지 않음으로 font-family, font-size 등 따로따로 써야함

### 15.7.2 SVG 스크립트

### 15.7.3 자바스크립트로 SVG 이미지 생성

- 자바스크립트로 문서에 포함된 svg를 조작할 수도 있지만, 처음부터 만드는 것도 가능하다.
- svg태그는 엄밀히 말하면 xml 태그이므로 createElement() 함수로는 svg 요소를 만들 수 없다
- xml 네임스페이스 문자열을 첫 번째 인자로 받는 createElementNS()를 사용해야 한다.

## 15.8 <canvas>의 그래픽

- <canvas> 요소는 그 자체로는 아무것도 표현하지 않지만 일종의 도화지를 만들고 클라이언트 사이드 자바스크립트에서 사용할 수 있는 강력한 API를 제공
- 캔버스 API와 SVG의 가장 큰 차이는 캔버스는 메서드를 호출하는 방식으로 그림을 그리는 반면， SVG는 XML 요소의 트리를 만드는 방식으로 그림을 그린다는 것
- SVG 그래픽은 요소를 삭제하는 방식으로 쉽게 수정가능
- <canvas>에서 같은 그래픽의 요소 하나를 제거하더라도 처음부터 다시 그려야 할 때가 많다
- 인자 2d를 넘겨서 getContext()를 호출하면 2차원 그래픽을 그릴 수 있는 CanvasRenderingContext2D 객체를 얻을 수 있다.
    
    ```jsx
    let context canvas.getContext("2d'’);
    ```
    

### 15.8.1 패스와 다각형

- 캔버스에 직선을 그리고 그 직선들로 둘러싸인 영역을 채울 때는 먼저 패스를 정의한다
- 패스는 하나 이상의 서브패스의 연속이다.
- 서브패스는 직선 또는 곡선으로 이어진 두 개 이상의 지점의 연속
- 새로운 패스를 시작할 때는 beginPath() 메서드를 사용
- 새로운 서브패스는 moveTo() 메서드로 시작합니다.
- moveTo( )로 서브패스의 출발점을 지정하면 lineTo()로 새로운 포인트까지 직선으로 연결할 수 있다
    
    ```jsx
    c.beginPath(); // 새로운 패스를 시작합니다.
    c.moveTo(100, 100); // (100, 100)에서 서브패스를 시작할니다.
    c.lineTo(200, 200); // (100, 100)에서 (200, 200)으로 직선을 그립니다.
    c.lineTo(100, 200); // (200, 200)에서 (100, 200)으로 직선을 추가합니다.
    ```
    
    - 이 코드는 패스를 정의하기만 할 뿐 캔버스에는 아무것도 그리지 않습니다.
    - 이 코드에 직선 두께와 채우기 색깔을 정하는 코드를 추가하면 삼각형이 그려진다
    - 두 개의 선분이 있을 뿐 출발점과 끝나는 점이 연결되지 않음
    - 삼각형의 세 변을 모두 그리고 싶다면 closePath( ) 메서드를 호출해서 출발점과 끝나는 점을 연결
    - lineTo(100，100)을 호출할 수도 있지만， 이렇게 하면 출발점과 끝나는 점을 공유하는 세 개의 선분이 생길 뿐 패스가 완전히 닫히지 않음

### 15.8.2 캔버스 크기와 좌표

- 이미지 품질을 최적화하려면 width , height 속성으로 캔버스의 화면 크기 를 지정하지 말아야 한다
- CSS의 width , height 스타일을 사용해서 원하는 화면 크기를 지정, 그리고 자바스크립트 코드에서 그림을 그리기 전에 캔버스 객체의 width,height 프로퍼티를 CSS 픽셀에 window.devicePixelRatio를 곱한 값으 로 설정
- 이 방법을 사용하더라도 사용자가 캔버스를 확대하면 그래픽 품질이 떨어질 수 있다.
- 화면 크기나 확대 레벨과 관계없이 일정한 수준을 유지하는 SVG 그래픽과는 이런 점에서 다르다.

## 15.9 오디오 API

- HTML `<audio>`, `<video>` 태그를 통해 웹 페이지에 사운드와 비디오를 넣을 수 있다
- 웹 브라우저는 audio 요소를 통해 녹음된 사운드를 재생하기도 하지만， WebAudio API를 통해 사운드를 직접 생성해서 재생할 수도 있다

## 15.10 위치， 내비게이션， 히스토리

- Window와 Document 객체의 location 프로퍼티는， 현재 창에 표시되는 문서의 URL을 나타내고 창에 새로운 문서를 불러오는 API를 제공하는 Location 객체를 참조한다.
- hash 프로퍼티는 URL에서 해시 마크(#)와 요소 ID로 구성된 부분이 있다면 그 부분을 나타내는 ‘해시 식별자 (fragment identifier)'를 반환
- search 프로퍼티도 이와 비슷하게 URL에서 물음표로 시작하는 부분을 반환하며 이 문자열은 대개 일종의 쿼리스트링으로 쓰인다.
- Location 객체의 프로퍼티는 쓰기 가능이며 이들의 값을 바꾸변 URL이 바뀌고 브라우저가 새로운 문서를 불러온다.
- hash 프로퍼티의 경우에는 현재 문서 안에서 이동
- Location 객체의 replace() 메서드는 아주 유용하다.
    - replace()에 문자열 을 전달하면 그 문자열은 URL로 해석되고 브라우저는 assign()과 마찬가지로 새로 운 페이지를 불러온다
    - 차이점은 replace()가 브라우저의 히스토리에 있는 현재 문서를 교체한다는 점
    - 문서 A에 있는 스크립트가 location 프로퍼티를 설정하거나 assign( )을 호출해서 문서 B를 불러온다면， 시용자가 뒤로 가기 버튼을 클릭했을 때 브라우저는 문서 A로 돌아간다.
    - 반면 replace()를 사용한다변， 브라우저 히스토리에서 문서 A가 삭제되므로 사용자가 뒤로 가기 버튼을 클릭하면 브라우저는 문서 A보다 먼저 표시했던 문서로 돌아간다.
- hashchange 이벤트를 통한 히스토리 관리
    - 문자열을 ID로 가진 요소가 없다면 hash 프로퍼티를 설정하더라도 브라우저는 스크롤하지 않는다
    - location.hash 프로퍼티를 설정하면 주소 표시줄에 표시되는 URL이 바뀌고 브라우저의 히스토리에 항목이 추가된다
    - 애플리케이션의 각 상태와 해시 식별자를 1:1로 대응시킨다면 hashchange 이벤트를 통해 사용자의 앞뒤 이동을 알 수 있다.
- pushState()를 사용한 히스토리 관리
    - 웹 애플리케이션은 새로운 상태로 전환할 때 history.pushState()를 호출해 현재 상태를 나타내는 객체를 브라우저의 히스토리에 추가한다
    - 그리고 사용자가 뒤로 가기 버튼을 클릭하면 브라우저는 저장된 상태 객체와 함께 popstate 이벤트를 일으키므로， 애플리케이션에서 이 객체를 사용해 이전 상태로 돌아갈 수 있다
    - pushState()의 첫 번째 인자는 문서의 현재 상태를 복원하는 데 필요한 상태 정보를 포함한 객체다. 이 객체는 HTML의 구조화된 클론 (structured clone) 알고리즘을 통해 저장된다. 이 알고리즘은 JSON. stringify()보다 강력하며 Map, Set, Date 객체，형식화 배열， ArrayBuffer도 지원한다.
