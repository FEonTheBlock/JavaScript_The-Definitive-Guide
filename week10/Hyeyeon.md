# 자바스크립트 완벽 가이드 10주차 학습 - 혜연

## 15장 웹 브라우저의 자바스크립트

### 15.7 SVG

- SVG: Scalable Vector Graphics, 확장성 있는 벡터 그래픽 이미지 형식
- SVG 이미지는 XML 마크업 언어를 사용해 텍스트 파일로 작성
- 웹 브라우저에서 SVG를 사용하는 방법
  1. <img> 태그 안에 .svg 이미지 파일 사용
  2. HTML 문서에 SVG 태그를 사용
  3. DOM API를 사용해 동적으로 SVG 요소 생성

#### 15.7.1 HTML 속 SVG

- SVG 이미지는 HTML 안에 <img> 태그로 표시하거나 SVG 태그를 사용하고, CSS 스타일시트로 폰트, 색깔, 행 너비 등을 지정할 수 있음.
- SVG 태그에서는 font 단축 프로퍼티가 동작하지 않음.

#### 15.7.2 SVG 스크립트

- HTML 파일에 SVG를 직접 넣으면 DOM API를 통해 SVG 이미지를 조작할 수 있음.
- script를 이용해 SVG 그래픽을 동적으로 조작할 수도 있음.

#### 15.7.3 자바스크립트로 SVG 이미지 생성

- 스크립트로 SVG 이미지를 만들면 동적으로 불러온 데이터를 시각화하는 용도 등으로 쓸 수 있음.
- createElement() 함수로는 SVG 요소를 만들 수 없고, createElementNS()를 사용해야 함.
- SVG 네임스페이스는 리터럴 문자열 'http://www.w3.org/2000/svg'
- SVG <path> 요소는 직선과 곡선으로 구성된 임의의 도형을 나타냄.

### 15.8 <canvas>의 그래픽

- <canvas> 요소는 일종의 도화지를 만들고 클라이언트 사이드 자바스크립트에서 사용할 수 있는 API를 제공함.
- SVG는 XML 요소의 트리를 만드는 방식으로 그림을 그리고, 캔버스 API는 메서드를 호출하는 방식으로 그림을 그림.
- SVG 그래픽은 요소를 삭제하여 수정할 수 있으나 캔버스는 처음부터 다시 그려야 하는 등 두 방법에 장점과 약점이 존재.
- 캔버스 API는 자바스크립트 기반이고 SVG 문법에 비해 비교적 간결함.

#### 15.8.1 패스와 다각형

- 캔버스에 직선을 그리고 그 직선들로 둘러싸인 영역을 채울 때는 하나 이상의 서브패스의 연속인 패스를 정의함.
- 서브패싀 직선 또는 곡선으로 이어진 두 개 이상의 지점의 연속

#### 15.8.2 캔버스 크기와 좌표

- 캔버스의 크기는 <canvas> 요소의 sidth, height 속성, 이에 대응하는 Canvas 객체의 width, height 프로퍼티로 지정됨.
- 캔버스의 기본 좌표계는 캔버스의 좌측 상단 모서리인 (0, 0) 지점을 원점으로 잡음.
- 캔버스의 크기를 수정하면 캔버스가 리셋됨.
- 이미지 품질을 최적화하려면 width, height 속성으로 캔버스의 화면 크기를 지정하지 않고 CSS의 width, height 스타일을 사용해서 지정해야 함.

#### 15.8.3 그래픽 속성

- 그래픽 상태와 그래픽 명령어를 구분하는 것이 캔버스 API의 기본적인 특징 중 하나
- 컨텍스트 객체의 다양한 프로퍼티와 메서드가 캔버스의 그래픽 상태에 영향을 미침.
- lineWidth 프로퍼티는 stroke()가 그리는 직선의 두께를 CSS 픽셀로 지정
- 너비가 2픽셀이 넘는 직선을 그릴 때 lineCap, lineJoin 프로퍼티를 사용해 패스의 끝, 선분이 만나는 꼭지점의 모양을 지정할 수 있음.
- fillStyle, strokeStyle 프로퍼티는 패스를 채우고 그리는 방법을 지정
- font 프로퍼티는 fillText(), strokeText() 메서드에서 사용할 텍스트 패턴의 폰트를 지정
  - font 프로퍼티의 값은 CSS font 속성과 같은 문법을 사용하는 문자열
- textAlign 프로퍼티는 tillText()나 strokeText()에 전달된 x좌표를 기준으로 텍스트를 가로 정렬하는 방법을 지정
- textBaseline 프로퍼티는 y좌표를 기준으로 텍스트를 세로 정렬하는 방법을 지정
- shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur 프로퍼티로 드롭 섀도우를 제어하여 그림자를 적용할 수 있음.
- strokeStyle이나 fillStyle에 rgba() 등의 문법을 사용해 반투명한 색깔을 쓸 수 있음.
- 합성(compositing): 기존 픽셀 위에 새로운 픽셀을 덧그리는 작업
- <canvas> 요소에는 컨텍스트 객체가 오직 하나만 존재하며 getContext()를 여러 번 호출하더라도 같은 CanvasRenderingContext2D 객체가 반환됨.
- save() 메서드는 현재 그래픽 상태를 스택에 추가하고, restore() 메서드는 스택의 마지막에 저장된 상태로 복원함.

#### 15.8.4 캔버스 그리기 동작

- 캔버스 API의 메서드를 이용하여 사각형, 곡선, 택스트, 이미지 등을 그릴 수 있음.

#### 15.8.5 좌표계 변환

- 캔버스는 항상 기본 좌표계 외에도 현재 변환 행렬을 그래픽 상태에 저장하며, 이 행렬은 캔버스의 현재 좌표계
- 대부분의 캔버스 동작에서 지점의 좌표를 지정하면 현재 좌표계를 기준으로 해석
- 현재 변환 행렬은 지정된 좌표를 기본 좌표계로 변환할 때 사용

#### 15.8.6 자르기

- clip() 메서드를 호출해 자르기 영역을 정의할 수 있음.
- 클립 영역 바깥에는 아무것도 그려지지 않음.

#### 15.8.7 픽셀 조작

- 픽셀 조작 메서드는 캔버스에 직접 접근하는 저수준 메서드로, 보션 블러 효과 등 이미지 처리에 적합

### 15.9 오디오 API

- HTML <audio>, <video> 태그를 통해 웹 페이지에 사운드와 비디오를 넣응ㄹ 수 있음.

#### 15.9.1 Audio() 생성자

- <audio> 태그를 사용하지 않아도 DOM의 document.createElement() 메서드로 <audio> 요소를 동적으로 생성하거나 Audio() 생성자를 사용해 사운드 효과를 이용할 수 있음.
- 생성한 요소를 문서에 추가하지 않고 play() 메서드를 호출하여 재생하면 재생을 마친 후 가비지 컬렉션 대상이 됨.

#### 15.9.2 WebAudio API

- WebAudioAPI를 통해 사운드를 직접 생성하여 재생할 수 있음.

### 15.10 위치, 내비게이션, 히스토리

- Window와 Document 객체의 location 프로퍼티는 현재 창에 표시되는 문서의 URL을 나타내고 창에 새로운 문서를 불러오는 API를 제공하는 Location 객체를 참조함.
- Location 객체의 protocol, hostname, port, path와 같은 프로퍼티를 사용해 현재 문서의 URL의 다양한 부분에 접근할 수 있음.
- URL 객체에는 search 프로퍼티를 분석한 결과인 searchParams 프로퍼티가 있음.

#### 15.10.1 새로운 문서 로딩

- window.location이나 document.location에 문자열을 할당하면 브라우저는 그 문자열을 URL로 해석하고 불러와서 현재 문서를 대체함.
- Location 객체의 replace() 메서드에 문자열을 전달하면 그 문자열은 URL로 해석되고 브라우저는 assign()과 마찬가지로 새로운 페이지를 불러오며 브라우저의 히스토리에 있는 현재 문서를 교체함.

#### 15.10.2 히스토리 브라우징

- Window 객체의 history 프로퍼티는 해당 창의 History 객체를 가리킴.
- History 객체는 창에서 불러왔던 문서와 그 상태의 리스트
- 브라우저 창에 <iframe> 요소 같은 자식 창이 포함되어 있다면 자식 창의 히스토리가 메인 창의 히스토리에 시간 순서대로 삽입됨.

#### 15.10.3 hashchange 이벤트를 통한 히스토리 관리(hashchange 이벤트를 원래 목적과 다르게 사용하는 편법에 가까움.)

- location.hash 프로퍼티는 URL의 해시 식별자를 설정하며 문자열을 요소 ID로 사용하면 스크롤할 섹션 ID로 지정할 수 있으며, 그 문자열을 ID로 가진 요소가 없다면 스크롤하지 않음.
- location.hash 프로퍼티를 설정하면 주소 표시줄에 표시되는 URL이 바뀌며, 브라우저의 히스토리에 항목이 추가됨.
- 문서의 해시 식별자가 바뀔 때마다 브라우저는 Window 객체에서 hashchange 이벤트를 일으키며 브라우저의 히스토리에 새로운 항목이 추가됨.
- 애플리케이션의 각 상태와 해시 식별자를 1:1로 대응시키면 hashchange 이벤트를 통해 사용자의 앞뒤 이동을 알 수 있음.

#### 15.10.4 pushState()를 사용한 히스토리 관리(복잡하지만 정석적인 방법)

- 사용자가 뒤로 가기나 앞으로 가기 버튼을 눌러서 저장된 상태로 이동하면 브라우저는 Window 객체에서 popstate 이벤트를 일으킴.
- 웹 애플리케이션이 새로운 상태로 전환될 때 history.pushState() 메서드를 호출해 현재 상태를 나타내는 객체를 브라우저의 히스토리에 추가하고, 뒤로 가기 버튼을 클릭하면 저장된 상태 객체와 함께 popstate 이벤트를 일으켜 이전 상태로 돌아갈 수 있음.
- History 객체의 replaceState() 메서드를 이용해 히스토리에 상태를 추가하지 않고 새로운 상태로 교체할 수 있음.
